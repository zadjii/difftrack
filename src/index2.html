<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>trackdiff test 2</title>
    <style type="text/css">
        table{
            width: 100%;
        }
        td {
            padding-right: 2em;
        }
        span {
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
<script src="..\dep\diff.js"></script>
<script src="..\dep\jquery-3.2.1.min.js"></script>
<script src="..\src\trackdiff.js"></script>
<script defer>

let colorPalette = [
    "#8888ff",
    "#f808aa",
    "#ffff88",
    "#4af8a8",
    "#888888",
    "#ff8888",
    "#88ff88",
    "#f8c8a8",
    "#ff88ff",
    "#88ffff",
    "#aa48fa",
    "#f84f4f",
];

function Point(x, y){
    this.x = x;
    this.y = y;
}

function PointColor(point, color){
    this.point = point;
    this.color = color;
}

function TextBlock(root, text, point_colors) {
    this._root = root;
    this._text = text;
    this._point_colors = point_colors.filter(a=>a.point.x != -1 && a.point.y != -1).sort((a, b)=>{
        if (a.point.y < b.point.y){ return -1;}
        else if (a.point.y > b.point.y){ return 1;}
        else {
            if (a.point.x < b.point.x){ return -1;}
            else if (a.point.x > b.point.x){ return 1;}
            else return 0;
        }
    });

    let _initialize = function (self) {
        let lines = self._text.split("\n");
        let pc_index = 0;
        let pc = self._point_colors.length > pc_index? self._point_colors[pc_index] : null;
        for (var row = 0; row < lines.length; row++) {
            let line = lines[row];
            if (pc != null && row == pc.point.y){
                let xs = [];
                let colors = [];

                for (var j = pc_index; j < self._point_colors.length; j++){
                    if (self._point_colors[j].point.y == row){
                        xs.push(self._point_colors[j].point.x);
                        colors.push(self._point_colors[j].color);
                    }
                    else if (self._point_colors[j].point.y > row) break;
                }

                pc_index += xs.length;
                pc = self._point_colors.length > pc_index? self._point_colors[pc_index] : null;

                if (xs.length > 0){
                    let next_index = 0;
                    let next_segment = "";
                    for (var char_index = 0; char_index < line.length; char_index++) {
                        let c = line[char_index];
                        if (char_index == xs[next_index]){
                            self._root.append($("<span>").text(next_segment));
                            self._root.append($("<span>").css("background", colors[next_index]).text(c));
                            // console.log(next_segment);
                            next_segment = "";
                            next_index++;
                            if (next_index >= xs.length){
                                self._root.append($("<span>").text(line.substring(char_index+1)));
                            }
                        }
                        else {
                            next_segment += c;
                        }
                    }

                }
                else {
                    self._root.append($("<span>").text(line));
                }
            }
            else {
                self._root.append($("<span>").text(line));
                console.log(line);
            }
            self._root.append($("<br>"));
        }
    };
    _initialize(this);
}

// "0x240A"
function test000_by_word() {
    console.log("starting test000_by_word");
    $("body").append($("<hr>"));
    let textA = "qwer\nasdf\nzxcv foo bar\n1234567890";
    let textB = "qwer\nasdf\nfoo bar baz\n1234567890";
    let points = [{x:0,y:0},{x:3,y:0},{x:2,y:2},{x:3,y:3},{x:9,y:2},{x:6,y:2}];
    let colors = colorPalette;
    new DiffBlock($("body"), textA, textB);
    new DiffPointsBlock($("body"), textA, textB, points.map((p, index)=>{return new PointColor(p, colors[index]);}));

    return true;
}

function DiffPointsBlock(root, textA, textB, point_colors) {
    this._root = root;
    this._textA = textA;
    this._textB = textB;
    this._initial_point_colors = point_colors;
    let _initialize = function (self) {
        // var diff_words = JsDiff.diffWords(textA, textB);
        var diff_words = JsDiff.diffWordsWithSpace(textA, textB);
        var diff_chars = JsDiff.diffChars(textA, textB);
        // console.log(JsDiff.structuredPatch("", "", textA, textB, "", ""));
        // var diff_lines = JsDiff.diffLines(textA, textB, {newlineIsToken:true});
        // var diff_lines = JsDiff.diffLines(textA, textB, false, true);
        console.log(diff_words);

        let final_point_colors = self._initial_point_colors.map(pc=>{return new PointColor(locate_point(pc.point, diff_words),  pc.color)});
        let final_point_colors_by_chars = self._initial_point_colors.map(pc=>{return new PointColor(locate_point(pc.point, diff_chars),  pc.color)});
        // let final_point_colors_by_lines = self._initial_point_colors.map(pc=>{return new PointColor(locate_point(pc.point, diff_lines),  pc.color)});

        // console.log(final_point_colors);
        // console.log(final_point_colors_by_chars);

        let table = $("<table>");
        self._root.append(table);
        let header = $("<tr>");
        table.append(header);
        header
            .append($("<th>").text("points"))
            .append($("<th>").text("initial text"))
            .append($("<th>").text("diff by words"))
            .append($("<th>").text("diff by chars"))
            ;
        let row = $("<tr>");
        table.append(row);
        let colA = $("<td>");
        let colB = $("<td>");
        let colC = $("<td>");
        let colD = $("<td>");
        // let colE = $("<td>");
        row.append(colA);
        row.append(colB);
        row.append(colC);
        row.append(colD);
        // row.append(colE);
        point_colors.map((pc,i)=>{
            colA.append(
                $("<div>")
                    .css("background", pc.color)
                    .text("("+pc.point.x+","+pc.point.y+") -> \n" + "("+final_point_colors[i].point.x+","+final_point_colors[i].point.y+"), " + "("+final_point_colors_by_chars[i].point.x+","+final_point_colors_by_chars[i].point.y+")")
            );
        });
        // let initial_pcs = points.map((p, index)=>{return new PointColor(p, colors[index]);});
        // let final_pcs = finals.map((p, index)=>{return new PointColor(p, colors[index]);});
        let blockA = new TextBlock(colB, textA, self._initial_point_colors);
        let blockB = new TextBlock(colC, textB, final_point_colors);
        let blockC = new TextBlock(colD, textB, final_point_colors_by_chars);
        // let blockD = new TextBlock(colE, textB, final_point_colors_by_lines);

    };
    _initialize(this);
}

function DiffBlock(root, textA, textB) {
    this._root = root;
    this._textA = textA;
    this._textB = textB;
    let _initialize = function (self) {
        var diff_words = JsDiff.diffWordsWithSpace(textA, textB);
        var diff_chars = JsDiff.diffChars(textA, textB);
        // var diffs = JsDiff.diffWords(textA, textB);
        let table = $("<table>");
        self._root.append(table);
        let header = $("<tr>");
        table.append(header);
        header
            .append($("<th>").text("textA"))
            .append($("<th>").text("textB"))
            .append($("<th>").text("diff by words"))
            .append($("<th>").text("diff by chars"))
            ;
        let row = $("<tr>");
        table.append(row);
        let colA = $("<td>");
        let colB = $("<td>");
        let colC = $("<td>");
        let colD = $("<td>");
        row.append(colA);
        row.append(colB);
        row.append(colC);
        row.append(colD);

        let blockA = new TextBlock(colA, textA, []);
        let blockB = new TextBlock(colB, textB, []);

        for (var i = 0; i < diff_words.length; i++) {
            let diff = diff_words[i];

            let lines = diff.value.split('\n');

            lines.map((line, index)=>{
                colC.append(
                    $("<span>")
                        .css("background", diff.added? ("#88ff88") : (diff.removed? ("#ff8888") : ("")))
                        .text(index < lines.length-1? (line + "\u240a") : (line))
                );
                if (index < lines.length-1) colC.append($("<br>"));
            });
        }

        for (var i = 0; i < diff_chars.length; i++) {
            let diff = diff_chars[i];
            let lines = diff.value.split('\n');
            lines.map((line, index)=>{
                colD.append(
                    $("<span>")
                        .css("background", diff.added? ("#88ff88") : (diff.removed? ("#ff8888") : ("")))
                        .text(index < lines.length-1? (line + "\u240a") : (line))
                );
                if (index < lines.length-1) colD.append($("<br>"));
            });
        }

    };
    _initialize(this);
}


function test001_by_word() {
    console.log("starting test001_by_word");
    $("body").append($("<hr>"));
    let textA = `TERMS AND CONDITIONS
A. TERMS OF SALE
B. ITUNES STORE TERMS AND CONDITIONS
C. MAC APP STORE, APP STORE, APP STORE FOR APPLE TV AND IBOOKS STORE TERMS AND CONDITIONS
D. APPLE MUSIC TERMS AND CONDITIONS
THE LEGAL AGREEMENTS SET OUT BELOW GOVERN YOUR USE OF THE ITUNES STORE, MAC APP STORE, APP STORE, APP STORE FOR APPLE TV, IBOOKS STORE AND APPLE MUSIC SERVICES ("SERVICES").`;
    let textB = `TERMS OR CONDITIONS
A. TERMS OF SALE
B. ITUNES STORE TERMS AND CONDITIONS
C. MAC APP STORE, APP STORE, APP STORE FOR APPLE TV TERMS AND CONDITIONS, AND SOMETHING ELSE
D. APPLE MUSIC TERMS AND CONDITIONS
THE LEGAL CONTRACTS SET OUT BELOW GOVERN YOUR USE OF THE ITUNES STORE, MAC APP STORE, APP STORE, APP STORE FOR APPLE TV, IBOOKS STORE AND APPLE MUSIC SERVICES ("SERVICES").`;
    let points = [{x:10,y:5},{x:10,y:0},{x:4,y:4},{x:69,y:3},{x:79,y:3},{x:25,y:5},{x:50,y:3},{x:53,y:3}];
    let colors = colorPalette;

    new DiffBlock($("body"), textA, textB);
    new DiffPointsBlock($("body"), textA, textB, points.map((p, index)=>{return new PointColor(p, colors[index]);}));

    return true;
}

function test002_by_word() {
    console.log("test002_by_word test000_by_word");
    $("body").append($("<hr>"));
    let textA = "abcd\nefgh\nijkl\nmnop\nqrst";
    let textB = "ubcd\nevgh\nijwl\nmnox\nqrst";
    let points = [{x:0,y:0},{x:3,y:0},{x:2,y:2},{x:3,y:3},{x:9,y:2},{x:6,y:2}];
    let colors = colorPalette;

    new DiffBlock($("body"), textA, textB);
    new DiffPointsBlock($("body"), textA, textB, points.map((p, index)=>{return new PointColor(p, colors[index]);}));

    return true;
}

function test003() {
    console.log("starting test003");
    $("body").append($("<hr>"));
    let textA = `
// This is a very, VERY simple c program

void main(){
    printf("hello, world");
    // return 0;
}
`;
    let textB = `
// This is a pretty simple C program
#include <stdio.h>
int main(int argc, char* argv){
    printf("hello there");

    for (int i = 0; i < argc; i++) {
        printf("%s\\n", argv[i]);
    }
    return 0;
}`;

    // So in this sample, when we diff by words, we get "-\n\nvoid", +"\nint".
    // This unfortunately tricks the algorithm here, because one of those \n should just remain unchanged.
    // Do I just check for an \n at the start of an removed then added string, then instead insert an unchanged \n?
    // I dunno if that's worth fixing - I doubt I could get that edge case totally right
    let points = [{x:13,y:1},{x:31,y:1},{x:34,y:1},{x:5,y:3},{x:6,y:4},{x:19,y:4},{x:8,y:5}];
    let void_points = [{x:0,y:3},{x:3,y:3},{x:4,y:3},{x:5,y:3}];
    let expected_points_by_word = [{x:13,y:1},{x:27,y:1},{x:30,y:1},{x:6,y:4}];
    let expected_points_by_char = [{x:13,y:1},{x:27,y:1},{x:30,y:1},{x:6,y:4}];
    let colors = colorPalette;

    new DiffBlock($("body"), textA, textB);
    // new DiffPointsBlock($("body"), textA, textB, points.map((p, index)=>{return new PointColor(p, colors[index]);}));
    new DiffPointsBlock($("body"), textA, textB, void_points.map((p, index)=>{return new PointColor(p, colors[index]);}));

    return true;
}

window.onload = function() {
    test003();
    // test002_by_word();
    // test001_by_word();
    // test000_by_word();
};
</script>
</body>
</html>
